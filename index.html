<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Webpage Title</title>
    <!-- You can link CSS files here -->
    <link rel="stylesheet" href="style.css">
</head>
<body class="body-hidden">
    <div id="navigation">
        <ul>
            <a class="studio" href="index.html"><li>Ian Roop Studio</li></a>
            <a class="link" href="info.html"><li>Info</li></a>
            <a class="link" href=""><li>Photography</li></a>
        </ul>
    </div>
    <div class="pan-container-js" id="panContainer">
        <div class="grid-container" id="gridContainer">            
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>                               
        </div>
    </div>

    <!-- Gallery Overlay -->
    <div class="gallery-overlay" id="galleryOverlay">
        <div class="gallery-container">
            <button class="gallery-close" id="galleryClose">Ã—</button>
            <button class="gallery-nav gallery-prev" id="galleryPrev">Prev</button>
            <button class="gallery-nav gallery-next" id="galleryNext">Next</button>
            <div class="gallery-loading" id="galleryLoading"></div>
            <img class="gallery-image" id="galleryImage" alt="Gallery Image">
            <div class="gallery-name" id="galleryName">Ian Roop Studio</div>
            <div class="gallery-caption" id="galleryCaption"></div>
            <div class="gallery-counter" id="galleryCounter">1 / 21</div>            
        </div>
    </div>
    <script>
    (function() {
        // Gallery System
        var Gallery = {
            overlay: null,
            image: null,
            loading: null,
            counter: null,
            caption: null,
            currentIndex: 0,
            totalItems: 0,
            gridItems: [],
            
            // Sample image URLs and captions - replace with your actual content
            imageUrls: [
                'https://picsum.photos/1200/800?random=1',
                'https://picsum.photos/1200/800?random=2',
                'https://picsum.photos/1200/800?random=3',
                'https://picsum.photos/1200/800?random=4',
                'https://picsum.photos/1200/800?random=5',
                'https://picsum.photos/1200/800?random=6',
                'https://picsum.photos/1200/800?random=7',
                'https://picsum.photos/1200/800?random=8',
                'https://picsum.photos/1200/800?random=9',
                'https://picsum.photos/1200/800?random=10',
                'https://picsum.photos/1200/800?random=11',
                'https://picsum.photos/1200/800?random=12',
                'https://picsum.photos/1200/800?random=13',
                'https://picsum.photos/1200/800?random=14',
                'https://picsum.photos/1200/800?random=15',
                'https://picsum.photos/1200/800?random=16',
                'https://picsum.photos/1200/800?random=17',
                'https://picsum.photos/1200/800?random=18',
                'https://picsum.photos/1200/800?random=19',
                'https://picsum.photos/1200/800?random=20',
                'https://picsum.photos/1200/800?random=21'
            ],
            
            // Sample captions - replace with your actual captions
            captions: [
                'Landscape photography capturing the golden hour light',
                'Urban architecture and geometric patterns',
                'Portrait session with natural lighting',
                'Abstract composition with dramatic shadows',
                'Nature photography showcasing organic forms',
                'Street photography moment frozen in time',
                'Architectural detail study in black and white',
                'Environmental portrait in natural setting',
                'Conceptual photography exploring texture and form',
                'Documentary photography telling a story',
                'Fine art photography with minimalist approach',
                'Commercial photography with creative lighting',
                'Travel photography capturing cultural moments',
                'Fashion photography with artistic direction',
                'Still life composition with careful arrangement',
                'Experimental photography pushing boundaries',
                'Wedding photography capturing intimate moments',
                'Product photography with studio lighting',
                'Event photography documenting celebrations',
                'Aerial photography showing new perspectives',
                'Night photography with long exposure techniques'
            ],
            
            init: function() {
                console.log('Gallery: Initializing...');
                this.overlay = document.getElementById('galleryOverlay');
                this.image = document.getElementById('galleryImage');
                this.loading = document.getElementById('galleryLoading');
                this.counter = document.getElementById('galleryCounter');
                this.caption = document.getElementById('galleryCaption');
                this.gridItems = Array.from(document.querySelectorAll('.grid-item'));
                this.totalItems = this.gridItems.length;
                
                console.log('Gallery: Found', this.totalItems, 'grid items');
                console.log('Gallery: Overlay element:', this.overlay);
                
                if (!this.overlay) {
                    console.error('Gallery: Overlay element not found!');
                    return;
                }
                
                this.bindEvents();
                this.setupGridItems();
                console.log('Gallery: Initialization complete');
            },
            
            setupGridItems: function() {
                var self = this;
                console.log('Gallery: Setting up grid item click handlers');
                this.gridItems.forEach(function(item, index) {
                    item.style.cursor = 'pointer';
                    item.setAttribute('data-gallery-index', index);
                    
                    // Improved touch handling for mobile
                    var touchStartX = 0;
                    var touchStartY = 0;
                    var touchMoved = false;
                    
                    // Touch events
                    item.addEventListener('touchstart', function(e) {
                        console.log('Gallery: Touch start on item', index);
                        var touch = e.touches[0];
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        touchMoved = false;
                        // Don't prevent default here to allow panning to still work
                    }, { passive: true });
                    
                    item.addEventListener('touchmove', function(e) {
                        if (e.touches.length > 0) {
                            var touch = e.touches[0];
                            var deltaX = Math.abs(touch.clientX - touchStartX);
                            var deltaY = Math.abs(touch.clientY - touchStartY);
                            
                            // If movement is more than 10px, consider it a pan gesture
                            if (deltaX > 10 || deltaY > 10) {
                                touchMoved = true;
                            }
                        }
                    }, { passive: true });
                    
                    item.addEventListener('touchend', function(e) {
                        console.log('Gallery: Touch end on item', index, 'moved:', touchMoved);
                        e.preventDefault(); // Prevent mouse events from firing
                        e.stopPropagation();
                        
                        // Only open gallery if this wasn't a pan gesture
                        if (!touchMoved) {
                            console.log('Gallery: Opening gallery from touch');
                            self.open(index);
                        }
                    }, { passive: false });
                    
                    // Keep mouse events for desktop
                    item.addEventListener('click', function(e) {
                        console.log('Gallery: Grid item', index, 'clicked via click event');
                        e.stopPropagation();
                        e.preventDefault();
                        self.open(index);
                    }, { passive: false });
                });
            },
            
            bindEvents: function() {
                var self = this;
                
                // Close events
                document.getElementById('galleryClose').addEventListener('click', function(e) {
                    e.preventDefault();
                    self.close();
                });
                
                document.getElementById('galleryClose').addEventListener('touchend', function(e) {
                    e.preventDefault();
                    self.close();
                });
                
                this.overlay.addEventListener('click', function(e) {
                    // Only close if clicking on the overlay itself, not the container or its children
                    if (e.target === self.overlay) {
                        self.close();
                    }
                });
                
                this.overlay.addEventListener('touchend', function(e) {
                    // Only close if touching the overlay itself, not the container or its children
                    if (e.target === self.overlay) {
                        e.preventDefault();
                        self.close();
                    }
                });
                
                // Navigation
                document.getElementById('galleryPrev').addEventListener('click', function(e) {
                    e.preventDefault();
                    self.prev();
                });
                
                document.getElementById('galleryPrev').addEventListener('touchend', function(e) {
                    e.preventDefault();
                    self.prev();
                });
                
                document.getElementById('galleryNext').addEventListener('click', function(e) {
                    e.preventDefault();
                    self.next();
                });
                
                document.getElementById('galleryNext').addEventListener('touchend', function(e) {
                    e.preventDefault();
                    self.next();
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', function(e) {
                    if (!self.overlay.classList.contains('active')) return;
                    
                    switch(e.key) {
                        case 'Escape':
                            self.close();
                            break;
                        case 'ArrowLeft':
                            self.prev();
                            break;
                        case 'ArrowRight':
                            self.next();
                            break;
                    }
                });
                
                // Swipe gestures for mobile
                var swipeStartX = 0;
                var swipeStartY = 0;
                var swipeTarget = null;
                
                this.overlay.addEventListener('touchstart', function(e) {
                    // Only handle swipes on the image or overlay background
                    if (e.target === self.overlay || e.target === self.image) {
                        var touch = e.touches[0];
                        swipeStartX = touch.clientX;
                        swipeStartY = touch.clientY;
                        swipeTarget = e.target;
                    }
                }, { passive: true });
                
                this.overlay.addEventListener('touchend', function(e) {
                    if (!swipeTarget || e.changedTouches.length === 0) return;
                    
                    var touch = e.changedTouches[0];
                    var deltaX = touch.clientX - swipeStartX;
                    var deltaY = touch.clientY - swipeStartY;
                    
                    // Close gallery if tapping on overlay background (not swiping)
                    if (swipeTarget === self.overlay && Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                        self.close();
                        swipeTarget = null;
                        return;
                    }
                    
                    // Only trigger swipe navigation if horizontal movement is greater than vertical
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                        if (deltaX > 0) {
                            self.prev(); // Swipe right = previous
                        } else {
                            self.next(); // Swipe left = next
                        }
                    }
                    
                    swipeTarget = null;
                }, { passive: true });
            },
            
            open: function(index) {
                console.log('Gallery: Opening gallery at index', index);
                this.currentIndex = index;
                
                if (!this.overlay) {
                    console.error('Gallery: Cannot open - overlay not found');
                    return;
                }
                
                // Force show the overlay with inline styles as backup
                this.overlay.style.display = 'flex';
                this.overlay.style.opacity = '1';
                this.overlay.style.visibility = 'visible';
                
                this.overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                console.log('Gallery: Overlay should now be visible');
                this.loadImage();
            },
            
            close: function() {
                console.log('Gallery: Closing gallery');
                this.overlay.classList.remove('active');
                this.overlay.style.display = '';
                this.overlay.style.opacity = '';
                this.overlay.style.visibility = '';
                document.body.style.overflow = '';
                this.image.classList.remove('loaded');
            },
            
            prev: function() {
                this.currentIndex = (this.currentIndex - 1 + this.totalItems) % this.totalItems;
                this.loadImage();
            },
            
            next: function() {
                this.currentIndex = (this.currentIndex + 1) % this.totalItems;
                this.loadImage();
            },
            
            loadImage: function() {
                var self = this;
                var imageUrl = this.imageUrls[this.currentIndex];
                var imageCaption = this.captions[this.currentIndex] || '';
                
                console.log('Gallery: Loading image', this.currentIndex + 1, 'of', this.totalItems);
                
                // Show loading indicator
                if (this.loading) {
                    this.loading.style.display = 'block';
                }
                if (this.image) {
                    this.image.classList.remove('loaded');
                }
                
                // Update counter
                if (this.counter) {
                    this.counter.textContent = (this.currentIndex + 1) + ' / ' + this.totalItems;
                }
                
                // Update caption
                if (this.caption) {
                    this.caption.textContent = imageCaption;
                }
                
                // Create new image to preload
                var newImage = new Image();
                newImage.onload = function() {
                    console.log('Gallery: Image loaded successfully');
                    if (self.image) {
                        self.image.src = imageUrl;
                        self.image.classList.add('loaded');
                    }
                    if (self.loading) {
                        self.loading.style.display = 'none';
                    }
                };
                newImage.onerror = function() {
                    console.log('Gallery: Image failed to load, using fallback');
                    // Fallback for broken images
                    if (self.image) {
                        self.image.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD48L3N2Zz4=';
                        self.image.classList.add('loaded');
                    }
                    if (self.loading) {
                        self.loading.style.display = 'none';
                    }
                };
                newImage.src = imageUrl;
            }
        };
        
        // Existing panning code...
        var panContainer = document.getElementById('panContainer');
        var gridContainer = document.getElementById('gridContainer');
        var isDragging = false;
        var startX = 0;
        var startY = 0;
        var currentX = 0;
        var currentY = 0;
        var mouseTrackingX = 0;
        var mouseTrackingY = 0;
        var targetMouseX = 0;
        var targetMouseY = 0;
        var mouseAnimationId = null;
        var mouseEnteredViewport = false;

        // Trackpad momentum and smoothing
        var momentumX = 0;
        var momentumY = 0;
        var isDecelerating = false;
        var decelerationFactor = 0.95;
        var minMomentum = 0.1;

        function updateTransform() {
            var totalX = currentX + mouseTrackingX;
            var totalY = currentY + mouseTrackingY;
            gridContainer.style.transform = 'translate(' + totalX + 'px, ' + totalY + 'px)';
        }

        function applyConstraints(newX, newY) {
            // Get container and grid dimensions
            var containerRect = panContainer.getBoundingClientRect();
            var gridRect = gridContainer.getBoundingClientRect();
            
            // Calculate 5% constraint boundaries
            var constraintX = gridRect.width * 0.05;
            var constraintY = gridRect.height * 0.05;
            
            // Calculate max allowed translation
            var maxX = (gridRect.width - containerRect.width) / 2 + constraintX;
            var maxY = (gridRect.height - containerRect.height) / 2 + constraintY;
            
            // Apply constraints
            return {
                x: Math.max(-maxX, Math.min(maxX, newX)),
                y: Math.max(-maxY, Math.min(maxY, newY))
            };
        }

        // Smooth mouse tracking animation
        function animateMouseTracking() {
            var lerpFactor = 0.08;
            
            var deltaX = targetMouseX - mouseTrackingX;
            var deltaY = targetMouseY - mouseTrackingY;
            
            if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                mouseTrackingX += deltaX * lerpFactor;
                mouseTrackingY += deltaY * lerpFactor;
                
                if (!isDragging) {
                    updateTransform();
                }
                
                mouseAnimationId = requestAnimationFrame(animateMouseTracking);
            } else {
                mouseTrackingX = targetMouseX;
                mouseTrackingY = targetMouseY;
                if (!isDragging) {
                    updateTransform();
                }
                mouseAnimationId = null;
            }
        }

        function handleStart(clientX, clientY) {
            isDragging = true;
            startX = clientX - currentX;
            startY = clientY - currentY;
            panContainer.style.cursor = 'grabbing';
            
            // Disable CSS transition during panning
            gridContainer.style.transition = 'none';
            
            // Stop any momentum when starting to drag
            momentumX = 0;
            momentumY = 0;
            isDecelerating = false;
            
            // Stop mouse tracking animation during drag
            if (mouseAnimationId) {
                cancelAnimationFrame(mouseAnimationId);
                mouseAnimationId = null;
            }
        }

        function handleMove(clientX, clientY) {
            if (!isDragging) return;
            
            var newX = clientX - startX;
            var newY = clientY - startY;
            
            var constrained = applyConstraints(newX, newY);
            currentX = constrained.x;
            currentY = constrained.y;
            
            updateTransform();
        }

        function handleEnd() {
            isDragging = false;
            panContainer.style.cursor = 'grab';
            
            // Re-enable CSS transition after panning
            setTimeout(function() {
                gridContainer.style.transition = 'transform 1.5s cubic-bezier(0.25, 1, 0.5, 1)';
            }, 100);
        }

        // Momentum animation function
        function animateMomentum() {
            if (!isDecelerating || (Math.abs(momentumX) < minMomentum && Math.abs(momentumY) < minMomentum)) {
                isDecelerating = false;
                return;
            }

            var constrained = applyConstraints(currentX + momentumX, currentY + momentumY);
            currentX = constrained.x;
            currentY = constrained.y;
            
            momentumX *= decelerationFactor;
            momentumY *= decelerationFactor;
            
            updateTransform();
            requestAnimationFrame(animateMomentum);
        }

        // Mouse tracking for subtle movement (Desktop only)
        if (window.innerWidth > 768) {
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) {
                    // Calculate mouse position relative to viewport center
                    var viewportCenterX = window.innerWidth / 2;
                    var viewportCenterY = window.innerHeight / 2;
                    
                    // Calculate offset from center as percentage
                    var offsetX = (e.clientX - viewportCenterX) / viewportCenterX;
                    var offsetY = (e.clientY - viewportCenterY) / viewportCenterY;
                    
                    // Apply 2% movement
                    var maxMovement = Math.min(window.innerWidth, window.innerHeight) * 0.02;
                    targetMouseX = offsetX * maxMovement;
                    targetMouseY = offsetY * maxMovement;
                    
                    // Start smooth animation if not already running
                    if (!mouseAnimationId) {
                        animateMouseTracking();
                    }
                } else {
                    // During drag, handle drag movement
                    handleMove(e.clientX, e.clientY);
                }
            });

            // Handle mouse enter/leave for smoother transitions
            document.addEventListener('mouseenter', function() {
                mouseEnteredViewport = true;
            });

            document.addEventListener('mouseleave', function() {
                mouseEnteredViewport = false;
                // Gradually return to center when mouse leaves
                targetMouseX = 0;
                targetMouseY = 0;
                if (!mouseAnimationId && !isDragging) {
                    animateMouseTracking();
                }
            });

            // Mouse events
            panContainer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                handleStart(e.clientX, e.clientY);
            }, { passive: false });

            document.addEventListener('mouseup', handleEnd, { passive: false });
        }

        // Touch events for panning (Desktop only)
        if (window.innerWidth > 768) {
            panContainer.addEventListener('touchstart', function(e) {
                // Only handle panning if it's not a grid item
                if (e.target.classList.contains('grid-item')) return;
                
                e.preventDefault();
                var touch = e.touches[0];
                handleStart(touch.clientX, touch.clientY);
            }, { passive: false });

            document.addEventListener('touchmove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    var touch = e.touches[0];
                    handleMove(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            document.addEventListener('touchend', function(e) {
                if (isDragging) {
                    handleEnd();
                }
            }, { passive: false });
        }
        // Trackpad/wheel event handling (Desktop only)
        if (window.innerWidth > 768) {
            panContainer.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                // Disable transition during wheel/trackpad panning
                gridContainer.style.transition = 'none';
                
                // Stop any ongoing momentum
                isDecelerating = false;
                
                // Determine if this is a trackpad (smoother, smaller values) or mouse wheel
                var isTrackpad = Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) < 50;
                var sensitivity = isTrackpad ? 1.0 : 0.5;
                
                // Apply movement with sensitivity
                var deltaX = -e.deltaX * sensitivity;
                var deltaY = -e.deltaY * sensitivity;
                
                var constrained = applyConstraints(currentX + deltaX, currentY + deltaY);
                currentX = constrained.x;
                currentY = constrained.y;
                
                // For trackpad, add momentum for smooth feel
                if (isTrackpad) {
                    momentumX = deltaX * 0.3;
                    momentumY = deltaY * 0.3;
                    
                    // Start momentum animation after a short delay
                    clearTimeout(window.momentumTimeout);
                    window.momentumTimeout = setTimeout(function() {
                        if (!isDragging && !isDecelerating) {
                            isDecelerating = true;
                            animateMomentum();
                        }
                    }, 50);
                }
                
                updateTransform();
            }, { passive: false });
        }
        
        // Initialize Gallery
        console.log('Initializing Gallery...');
        Gallery.init();
    })();
    </script>    
</body>
</html>