<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Webpage Title</title>
    <!-- You can link CSS files here -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="navigation">
        <ul>
            <a class="studio" href="index.html"><li>Ian Roop Studio</li></a>
            <a class="link" href="info.html"><li>Info</li></a>
            <a class="link" href=""><li>Photography</li></a>
        </ul>
    </div>
    <div class="pan-container-js" id="panContainer">
        <div class="grid-container" id="gridContainer">            
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>
                <div class="grid-item"></div>                               
        </div>
    </div>

    <!-- Gallery Overlay -->
    <div class="gallery-overlay" id="galleryOverlay">
        <div class="gallery-container">
            <button class="gallery-close" id="galleryClose">Ã—</button>
            <button class="gallery-nav gallery-prev" id="galleryPrev">Prev</button>
            <button class="gallery-nav gallery-next" id="galleryNext">Next</button>
            <div class="gallery-loading" id="galleryLoading"></div>
            <img class="gallery-image" id="galleryImage" alt="Gallery Image">
            <div class="gallery-counter" id="galleryCounter">1 / 21</div>            
        </div>
    </div>
    <script>
    (function() {
        // Gallery System
        var Gallery = {
            overlay: null,
            image: null,
            loading: null,
            counter: null,
            currentIndex: 0,
            totalItems: 0,
            gridItems: [],
            
            // Sample image URLs - replace with your actual images
            imageUrls: [
                'https://picsum.photos/1200/800?random=1',
                'https://picsum.photos/1200/800?random=2',
                'https://picsum.photos/1200/800?random=3',
                'https://picsum.photos/1200/800?random=4',
                'https://picsum.photos/1200/800?random=5',
                'https://picsum.photos/1200/800?random=6',
                'https://picsum.photos/1200/800?random=7',
                'https://picsum.photos/1200/800?random=8',
                'https://picsum.photos/1200/800?random=9',
                'https://picsum.photos/1200/800?random=10',
                'https://picsum.photos/1200/800?random=11',
                'https://picsum.photos/1200/800?random=12',
                'https://picsum.photos/1200/800?random=13',
                'https://picsum.photos/1200/800?random=14',
                'https://picsum.photos/1200/800?random=15',
                'https://picsum.photos/1200/800?random=16',
                'https://picsum.photos/1200/800?random=17',
                'https://picsum.photos/1200/800?random=18',
                'https://picsum.photos/1200/800?random=19',
                'https://picsum.photos/1200/800?random=20',
                'https://picsum.photos/1200/800?random=21'
            ],
            
            init: function() {
                console.log('Gallery: Initializing...');
                this.overlay = document.getElementById('galleryOverlay');
                this.image = document.getElementById('galleryImage');
                this.loading = document.getElementById('galleryLoading');
                this.counter = document.getElementById('galleryCounter');
                this.gridItems = Array.from(document.querySelectorAll('.grid-item'));
                this.totalItems = this.gridItems.length;
                
                console.log('Gallery: Found', this.totalItems, 'grid items');
                console.log('Gallery: Overlay element:', this.overlay);
                
                if (!this.overlay) {
                    console.error('Gallery: Overlay element not found!');
                    return;
                }
                
                this.bindEvents();
                this.setupGridItems();
                console.log('Gallery: Initialization complete');
            },
            
            setupGridItems: function() {
                var self = this;
                console.log('Gallery: Setting up grid item click handlers');
                this.gridItems.forEach(function(item, index) {
                    item.style.cursor = 'pointer';
                    item.setAttribute('data-gallery-index', index);
                    
                    // Use both click and mouseup for better compatibility
                    item.addEventListener('click', function(e) {
                        console.log('Gallery: Grid item', index, 'clicked via click event');
                        e.stopPropagation();
                        self.open(index);
                    }, { passive: false });
                    
                    item.addEventListener('mouseup', function(e) {
                        console.log('Gallery: Grid item', index, 'clicked via mouseup event');
                        e.stopPropagation();
                        // Only trigger if this wasn't a drag operation
                        if (Math.abs(e.clientX - (e.target._startX || e.clientX)) < 5 &&
                            Math.abs(e.clientY - (e.target._startY || e.clientY)) < 5) {
                            self.open(index);
                        }
                    }, { passive: false });
                    
                    item.addEventListener('mousedown', function(e) {
                        e.target._startX = e.clientX;
                        e.target._startY = e.clientY;
                    }, { passive: false });
                });
            },
            
            bindEvents: function() {
                var self = this;
                
                // Close events
                document.getElementById('galleryClose').addEventListener('click', function() {
                    self.close();
                });
                
                this.overlay.addEventListener('click', function(e) {
                    if (e.target === self.overlay) {
                        self.close();
                    }
                });
                
                // Navigation
                document.getElementById('galleryPrev').addEventListener('click', function() {
                    self.prev();
                });
                
                document.getElementById('galleryNext').addEventListener('click', function() {
                    self.next();
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', function(e) {
                    if (!self.overlay.classList.contains('active')) return;
                    
                    switch(e.key) {
                        case 'Escape':
                            self.close();
                            break;
                        case 'ArrowLeft':
                            self.prev();
                            break;
                        case 'ArrowRight':
                            self.next();
                            break;
                    }
                });
            },
            
            open: function(index) {
                console.log('Gallery: Opening gallery at index', index);
                this.currentIndex = index;
                
                if (!this.overlay) {
                    console.error('Gallery: Cannot open - overlay not found');
                    return;
                }
                
                // Force show the overlay with inline styles as backup
                this.overlay.style.display = 'flex';
                this.overlay.style.opacity = '1';
                this.overlay.style.visibility = 'visible';
                
                this.overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                console.log('Gallery: Overlay should now be visible');
                this.loadImage();
            },
            
            close: function() {
                console.log('Gallery: Closing gallery');
                this.overlay.classList.remove('active');
                this.overlay.style.display = '';
                this.overlay.style.opacity = '';
                this.overlay.style.visibility = '';
                document.body.style.overflow = '';
                this.image.classList.remove('loaded');
            },
            
            prev: function() {
                this.currentIndex = (this.currentIndex - 1 + this.totalItems) % this.totalItems;
                this.loadImage();
            },
            
            next: function() {
                this.currentIndex = (this.currentIndex + 1) % this.totalItems;
                this.loadImage();
            },
            
            loadImage: function() {
                var self = this;
                var imageUrl = this.imageUrls[this.currentIndex];
                
                console.log('Gallery: Loading image', this.currentIndex + 1, 'of', this.totalItems);
                
                // Show loading indicator
                if (this.loading) {
                    this.loading.style.display = 'block';
                }
                if (this.image) {
                    this.image.classList.remove('loaded');
                }
                
                // Update counter
                if (this.counter) {
                    this.counter.textContent = (this.currentIndex + 1) + ' / ' + this.totalItems;
                }
                
                // Create new image to preload
                var newImage = new Image();
                newImage.onload = function() {
                    console.log('Gallery: Image loaded successfully');
                    if (self.image) {
                        self.image.src = imageUrl;
                        self.image.classList.add('loaded');
                    }
                    if (self.loading) {
                        self.loading.style.display = 'none';
                    }
                };
                newImage.onerror = function() {
                    console.log('Gallery: Image failed to load, using fallback');
                    // Fallback for broken images
                    if (self.image) {
                        self.image.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD48L3N2Zz4=';
                        self.image.classList.add('loaded');
                    }
                    if (self.loading) {
                        self.loading.style.display = 'none';
                    }
                };
                newImage.src = imageUrl;
            }
        };
        
        // Existing panning code...
            var panContainer = document.getElementById('panContainer');
            var gridContainer = document.getElementById('gridContainer');
            var isDragging = false;
            var startX = 0;
            var startY = 0;
            var currentX = 0;
            var currentY = 0;
            var mouseTrackingX = 0;
            var mouseTrackingY = 0;
            var targetMouseX = 0;
            var targetMouseY = 0;
            var mouseAnimationId = null;
            var mouseEnteredViewport = false;

            // Trackpad momentum and smoothing
            var momentumX = 0;
            var momentumY = 0;
            var isDecelerating = false;
            var decelerationFactor = 0.95;
            var minMomentum = 0.1;

            function updateTransform() {
                var totalX = currentX + mouseTrackingX;
                var totalY = currentY + mouseTrackingY;
                gridContainer.style.transform = 'translate(' + totalX + 'px, ' + totalY + 'px)';
            }

            function applyConstraints(newX, newY) {
                // Get container and grid dimensions
                var containerRect = panContainer.getBoundingClientRect();
                var gridRect = gridContainer.getBoundingClientRect();
                
                // Calculate 5% constraint boundaries
                var constraintX = gridRect.width * 0.05;
                var constraintY = gridRect.height * 0.05;
                
                // Calculate max allowed translation
                var maxX = (gridRect.width - containerRect.width) / 2 + constraintX;
                var maxY = (gridRect.height - containerRect.height) / 2 + constraintY;
                
                // Apply constraints
                return {
                    x: Math.max(-maxX, Math.min(maxX, newX)),
                    y: Math.max(-maxY, Math.min(maxY, newY))
                };
            }

            // Smooth mouse tracking animation
            function animateMouseTracking() {
                var lerpFactor = 0.08; // Adjust for smoothness (0.02 = very smooth, 0.2 = snappy)
                
                var deltaX = targetMouseX - mouseTrackingX;
                var deltaY = targetMouseY - mouseTrackingY;
                
                if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                    mouseTrackingX += deltaX * lerpFactor;
                    mouseTrackingY += deltaY * lerpFactor;
                    
                    if (!isDragging) {
                        updateTransform();
                    }
                    
                    mouseAnimationId = requestAnimationFrame(animateMouseTracking);
                } else {
                    mouseTrackingX = targetMouseX;
                    mouseTrackingY = targetMouseY;
                    if (!isDragging) {
                        updateTransform();
                    }
                    mouseAnimationId = null;
                }
            }

            function handleStart(clientX, clientY) {
                isDragging = true;
                startX = clientX - currentX;
                startY = clientY - currentY;
                panContainer.style.cursor = 'grabbing';
                
                // Disable CSS transition during panning
                gridContainer.style.transition = 'none';
                
                // Stop any momentum when starting to drag
                momentumX = 0;
                momentumY = 0;
                isDecelerating = false;
                
                // Stop mouse tracking animation during drag
                if (mouseAnimationId) {
                    cancelAnimationFrame(mouseAnimationId);
                    mouseAnimationId = null;
                }
            }

            function handleMove(clientX, clientY) {
                if (!isDragging) return;
                
                var newX = clientX - startX;
                var newY = clientY - startY;
                
                var constrained = applyConstraints(newX, newY);
                currentX = constrained.x;
                currentY = constrained.y;
                
                updateTransform();
            }

            function handleEnd() {
                isDragging = false;
                panContainer.style.cursor = 'grab';
                
                // Re-enable CSS transition after panning
                setTimeout(function() {
                    gridContainer.style.transition = 'transform 1.5s cubic-bezier(0.25, 1, 0.5, 1)';
                }, 100);
            }

            // Momentum animation function
            function animateMomentum() {
                if (!isDecelerating || (Math.abs(momentumX) < minMomentum && Math.abs(momentumY) < minMomentum)) {
                    isDecelerating = false;
                    return;
                }

                var constrained = applyConstraints(currentX + momentumX, currentY + momentumY);
                currentX = constrained.x;
                currentY = constrained.y;
                
                momentumX *= decelerationFactor;
                momentumY *= decelerationFactor;
                
                updateTransform();
                requestAnimationFrame(animateMomentum);
            }

            // Mouse tracking for subtle movement
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) {
                    // Calculate mouse position relative to viewport center
                    var viewportCenterX = window.innerWidth / 2;
                    var viewportCenterY = window.innerHeight / 2;
                    
                    // Calculate offset from center as percentage
                    var offsetX = (e.clientX - viewportCenterX) / viewportCenterX;
                    var offsetY = (e.clientY - viewportCenterY) / viewportCenterY;
                    
                    // Apply 2% movement
                    var maxMovement = Math.min(window.innerWidth, window.innerHeight) * 0.02;
                    targetMouseX = offsetX * maxMovement;
                    targetMouseY = offsetY * maxMovement;
                    
                    // Start smooth animation if not already running
                    if (!mouseAnimationId) {
                        animateMouseTracking();
                    }
                } else {
                    // During drag, handle drag movement
                    handleMove(e.clientX, e.clientY);
                }
            });

            // Handle mouse enter/leave for smoother transitions
            document.addEventListener('mouseenter', function() {
                mouseEnteredViewport = true;
            });

            document.addEventListener('mouseleave', function() {
                mouseEnteredViewport = false;
                // Gradually return to center when mouse leaves
                targetMouseX = 0;
                targetMouseY = 0;
                if (!mouseAnimationId && !isDragging) {
                    animateMouseTracking();
                }
            });

            // Trackpad/wheel event handling
            panContainer.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                // Disable transition during wheel/trackpad panning
                gridContainer.style.transition = 'none';
                
                // Stop any ongoing momentum
                isDecelerating = false;
                
                // Determine if this is a trackpad (smoother, smaller values) or mouse wheel
                var isTrackpad = Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) < 50;
                var sensitivity = isTrackpad ? 1.0 : 0.5;
                
                // Apply movement with sensitivity
                var deltaX = -e.deltaX * sensitivity;
                var deltaY = -e.deltaY * sensitivity;
                
                var constrained = applyConstraints(currentX + deltaX, currentY + deltaY);
                currentX = constrained.x;
                currentY = constrained.y;
                
                // For trackpad, add momentum for smooth feel
                if (isTrackpad) {
                    momentumX = deltaX * 0.3;
                    momentumY = deltaY * 0.3;
                    
                    // Start momentum animation after a short delay
                    clearTimeout(window.momentumTimeout);
                    window.momentumTimeout = setTimeout(function() {
                        if (!isDragging && !isDecelerating) {
                            isDecelerating = true;
                            animateMomentum();
                        }
                    }, 50);
                }
                
                updateTransform();
            }, { passive: false });

            // Mouse events
            panContainer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                handleStart(e.clientX, e.clientY);
            }, { passive: false });

            document.addEventListener('mouseup', handleEnd, { passive: false });

            // Touch events
            panContainer.addEventListener('touchstart', function(e) {
                e.preventDefault();
                var touch = e.touches[0];
                handleStart(touch.clientX, touch.clientY);
            });

            document.addEventListener('touchmove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    var touch = e.touches[0];
                    handleMove(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchend', handleEnd, { passive: false });

            // Prevent grid item clicks from triggering drag
            var gridItems = document.querySelectorAll('.grid-item');
            for (var i = 0; i < gridItems.length; i++) {
                gridItems[i].addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                }, { passive: false });
            }
            
            // Initialize Gallery
            console.log('Initializing Gallery...');
            Gallery.init();
        })();
    </script>
</body>
</html>